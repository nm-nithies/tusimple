import cv2
import numpy as np
import os
from pathlib import Path

from nnac.core.log import Logger

logger = Logger("Evaluation - Lane Detection")


class cCfg:
    pass


cfg = cCfg()
cfg.w_lane = 30
cfg.iou = 0.5
cfg.im_w = 1640
cfg.im_h = 590
cfg.test_split_len = 9
cfg.list_dir = ['test0_normal.txt', 'test1_crowd.txt', 'test2_hlight.txt', 'test3_shadow.txt', 'test4_noline.txt',
                'test5_arrow.txt', 'test6_curve.txt', 'test7_cross.txt', 'test8_night.txt']


class BipartiteGraph:
    def __init__(self):
        self.mat = []
        self.left_used = []
        self.right_used = []
        self.left_weight = []
        self.right_weight = []
        self.right_match = []
        self.left_match = []
        self.left_num = 0
        self.right_num = 0

    def match_dfs(self, u):
        # Depth-first search to find augmenting paths for matching
        self.left_used[u] = True
        for v in range(self.right_num):
            if not self.right_used[v] and abs(self.left_weight[u] + self.right_weight[v] - self.mat[u][v]) < 1e-2:
                self.right_used[v] = True
                if self.right_match[v] == -1 or self.match_dfs(self.right_match[v]):
                    self.right_match[v] = u
                    self.left_match[u] = v
                    return True
        return False

    def resize(self, left_num, right_num):
        # Resize and initialize the graph for matching based on input dimensions
        self.left_num = left_num
        self.right_num = right_num
        self.left_match = [-1] * left_num
        self.right_match = [-1] * right_num
        self.left_used = [False] * left_num
        self.right_used = [False] * right_num
        self.left_weight = [0.0] * left_num
        self.right_weight = [0.0] * right_num
        self.mat = [[0.0] * right_num for _ in range(left_num)]

    def match(self):
        # Implement the Hungarian algorithm to find the maximum matching
        self.left_match = [-1] * self.left_num
        self.right_match = [-1] * self.right_num
        self.right_weight = [0.0] * self.right_num

        for i in range(self.left_num):
            self.left_weight[i] = -1e5
            for j in range(self.right_num):
                self.left_weight[i] = max(self.left_weight[i], self.mat[i][j])

        for u in range(self.left_num):
            while True:
                self.left_used = [False] * self.left_num
                self.right_used = [False] * self.right_num
                if self.match_dfs(u):
                    break
                d = 1e10
                for i in range(self.left_num):
                    if self.left_used[i]:
                        for j in range(self.right_num):
                            if not self.right_used[j]:
                                d = min(d, self.left_weight[i] + self.right_weight[j] - self.mat[i][j])
                if d == 1e10:
                    return
                for i in range(self.left_num):
                    if self.left_used[i]:
                        self.left_weight[i] -= d
                for i in range(self.right_num):
                    if self.right_used[i]:
                        self.right_weight[i] += d


class Func:
    def __init__(self):
        self.a_x = 0
        self.b_x = 0
        self.c_x = 0
        self.d_x = 0
        self.a_y = 0
        self.b_y = 0
        self.c_y = 0
        self.d_y = 0
        self.h = 0


def get_lane_similarity(lane1, lane2):
    '''This method calulates the similarity between two lanes, represented by sets
       of points. It uses interpolation if the number of points in a is greater than two.
       :return: iou
    '''
    if len(lane1) < 2 or len(lane2) < 2:
        print("Lane size must be greater or equal to 2")
        return 0

    im1 = np.zeros((cfg.im_h, cfg.im_w), dtype=np.uint8)
    im2 = np.zeros((cfg.im_h, cfg.im_w), dtype=np.uint8)

    if len(lane1) == 2:
        p_interp1 = lane1
    else:
        p_interp1 = spline_interp_times(lane1, 50)
    if len(lane2) == 2:
        p_interp2 = lane2
    else:
        p_interp2 = spline_interp_times(lane2, 50)
    color_white = 1
    for n in range(len(p_interp1) - 1):
        cv2.line(im1, tuple(map(int, p_interp1[n])), tuple(map(int, p_interp1[n + 1])), color_white, cfg.w_lane)
    for n in range(len(p_interp2) - 1):
        cv2.line(im2, tuple(map(int, p_interp2[n])), tuple(map(int, p_interp2[n + 1])), color_white, cfg.w_lane)

    sum_1 = np.sum(im1)
    sum_2 = np.sum(im2)
    inter_sum = np.sum(im1 * im2)
    union_sum = sum_1 + sum_2 - inter_sum
    iou = inter_sum / union_sum if union_sum != 0 else 0
    return iou


def spline_interp_times(tmp_line, times):
    '''This method calculates the interpolation for two points &
       cubic spline interpolation for three or more points.
       :return: list containing the interpolated points.
    '''
    res = []
    if len(tmp_line) == 2:
        x1, y1 = tmp_line[0]
        x2, y2 = tmp_line[1]
        for k in range(times + 1):
            xi = x1 + (x2 - x1) * k / times
            yi = y1 + (y2 - y1) * k / times
            res.append([xi, yi])
    elif len(tmp_line) > 2:
        tmp_func = spline_coefficients(tmp_line)
        for func in tmp_func:
            delta = func.h / times
            for k in range(times):
                t1 = delta * k
                x1 = func.a_x + func.b_x * t1 + func.c_x * np.power(t1, 2) + func.d_x * np.power(t1, 3)
                y1 = func.a_y + func.b_y * t1 + func.c_y * np.power(t1, 2) + func.d_y * np.power(t1, 3)
                res.append([x1, y1])
        res.append(tmp_line[-1])
    return res


def spline_coefficients(point_v):
    '''This method computes the coefficients for cubic spline interpolation using TDMA
       Tridiagonal matrix algorithm.
       :return: list of spline functions (Func) for each segment between the input points.
    '''
    func_v = []
    n = len(point_v)
    if n <= 2:
        return func_v
    func_v = [Func() for _ in range(n - 1)]
    Mx = np.zeros(n)
    My = np.zeros(n)
    A = np.zeros(n - 2)
    B = np.zeros(n - 2)
    C = np.zeros(n - 2)
    Dx = np.zeros(n - 2)
    Dy = np.zeros(n - 2)
    h = np.zeros(n - 1)

    for i in range(n - 1):
        h[i] = np.sqrt((point_v[i+1][0] - point_v[i][0])**2 + (point_v[i+1][1] - point_v[i][1])**2)
    for i in range(n - 2):
        A[i] = h[i]
        B[i] = 2 * (h[i] + h[i+1])
        C[i] = h[i+1]
        Dx[i] = 6 * ((point_v[i+2][0] - point_v[i+1][0]) / h[i+1] - (point_v[i+1][0] - point_v[i][0]) / h[i])
        Dy[i] = 6 * ((point_v[i+2][1] - point_v[i+1][1]) / h[i+1] - (point_v[i+1][1] - point_v[i][1]) / h[i])
    C[0] /= B[0]
    Dx[0] /= B[0]
    Dy[0] /= B[0]
    for i in range(1, n - 2):
        tmp = B[i] - A[i] * C[i - 1]
        C[i] /= tmp
        Dx[i] = (Dx[i] - A[i] * Dx[i - 1]) / tmp
        Dy[i] = (Dy[i] - A[i] * Dy[i - 1]) / tmp

    Mx[n-2] = Dx[n-3]
    My[n-2] = Dy[n-3]
    for i in range(n - 4, -1, -1):
        Mx[i+1] = Dx[i] - C[i] * Mx[i+2]
        My[i+1] = Dy[i] - C[i] * My[i+2]

    Mx[0] = 0
    Mx[n-1] = 0
    My[0] = 0
    My[n-1] = 0

    for i in range(n - 1):
        func_v[i].a_x = point_v[i][0]
        func_v[i].b_x = (point_v[i+1][0] - point_v[i][0]) / h[i] - (2 * h[i] * Mx[i] + h[i] * Mx[i+1]) / 6
        func_v[i].c_x = Mx[i] / 2
        func_v[i].d_x = (Mx[i+1] - Mx[i]) / (6 * h[i])
        func_v[i].a_y = point_v[i][1]
        func_v[i].b_y = (point_v[i+1][1] - point_v[i][1]) / h[i] - (2 * h[i] * My[i] + h[i] * My[i+1]) / 6
        func_v[i].c_y = My[i] / 2
        func_v[i].d_y = (My[i+1] - My[i]) / (6 * h[i])
        func_v[i].h = h[i]
    return func_v


def make_match(similarity, match1, match2):
    # Perform the Hungarian algorithm to find the optimal match between lanes
    m = len(similarity)
    n = len(similarity[0])
    gra = BipartiteGraph()
    have_exchange = False

    if m > n:
        have_exchange = True
        m, n = n, m

    gra.resize(m, n)
    for i in range(gra.left_num):
        for j in range(gra.right_num):
            if have_exchange:
                gra.mat[i][j] = similarity[j][i]
            else:
                gra.mat[i][j] = similarity[i][j]

    gra.match()
    match1[:] = gra.left_match
    match2[:] = gra.right_match

    if have_exchange:
        match1[:], match2[:] = match2[:], match1[:]
    return similarity, match1, match2


def read_lane_file(file_name):
    # Return annotation lanes
    lanes = []
    with open(file_name, 'r') as file:
        for line in file:
            points = list(map(float, line.split()))
            if len(points) % 2 != 0:
                raise ValueError("Each line must contain an even number of values")
            curr_lane = [np.array(points[i:i+2]) for i in range(0, len(points), 2)]
            lanes.append(curr_lane)
    return lanes


def count_im_pair(anno_lanes, detect_lanes):
    '''This method calculates the similarity matrix between lanes
       :return: [anno_match, tp, fp, fn]
    '''
    anno_match = [-1] * len(anno_lanes)
    detect_match = []
    if not anno_lanes:
        return [anno_match, 0, len(detect_lanes), 0, 0]

    if not detect_lanes:
        return [anno_match, 0, 0, 0, len(anno_lanes)]

    # Similarity matrix
    similarity = np.zeros((len(anno_lanes), len(detect_lanes)))

    for i in range(len(anno_lanes)):
        curr_anno_lane = anno_lanes[i]
        for j in range(len(detect_lanes)):
            curr_detect_lane = detect_lanes[j]
            similarity[i][j] = get_lane_similarity(curr_anno_lane, curr_detect_lane)

    similarity, anno_match, detect_match = make_match(similarity, anno_match, detect_match)
    curr_tp = 0
    for i in range(len(anno_lanes)):
        if anno_match[i] >= 0 and similarity[i][anno_match[i]] > cfg.iou:
            curr_tp += 1
        else:
            anno_match[i] = -1

    curr_fn = len(anno_lanes) - curr_tp
    curr_fp = len(detect_lanes) - curr_tp
    return [anno_match, curr_tp, curr_fp, 0, curr_fn]


def get_detected_lanes(filename, predictions):
    # Return detected lanes
    filename = Path(filename)
    if filename in predictions:
        lanes = predictions[filename]
        return lanes['lanes']
    else:
        return []


def calculate_metrics(predictions, anno_dir, reference_data_path):
    # This method calculates the tp, fp, fn
    filelists = []
    for i in range(cfg.test_split_len):
        list_path = os.path.join(reference_data_path, cfg.list_dir[i])
        with open(list_path, 'r') as f:
            for line in f:
                line = line.strip()
                filelists.append(line)

    tp, fp, fn = 0, 0, 0
    for pred in predictions:
        sub_im_name = str(pred)
        sub_txt_name = sub_im_name.rsplit(".", 1)[0] + ".lines.txt"
        anno_file_name = anno_dir + '/' + sub_txt_name
        anno_lanes = read_lane_file(anno_file_name)
        detect_lanes = get_detected_lanes(sub_im_name, predictions)
        output_list = count_im_pair(anno_lanes, detect_lanes)
        tp += output_list[1]
        fp += output_list[2]
        fn += output_list[4]

    output_dict = {}
    output_dict['tp'] = tp
    output_dict['fp'] = fp
    output_dict['fn'] = fn

    return output_dict


def evaluate(predictions, reference_data_path: Path):
    """
    # Model - RESANet_culane
    # Dataset - CULane

    ##  Accuracy Measurement

    The variables below are used to shorten the command-lines, set corresponding path for each.
    ```
    DATASET=/path/to/CULane/list/test.txt
    EXAMPLE_DIR=${NNSDK_TOP}/examples/public_models/RESANet_culane
    ```

    Use the following command-line to run RESANet_culane:

    ```
    accuracy --model_path PATH_TO_ONNX_OR_NNX \
    --inputs ${DATASET} \
    --reference_data /path/to/CULane/list/test_split \
    --preprocessing ${EXAMPLE_DIR}/model_data/preprocess.py \
    --postprocessing ${EXAMPLE_DIR}/model_data/postprocess.py \
    --metric lane_detection
    ```
    """
    reference_data_path = str(reference_data_path)
    dataset_path = reference_data_path[:reference_data_path.rfind("CULane") + len("CULane")]
    result_dict = {}
    result_dict = evaluate(predictions, dataset_path, reference_data_path)
    TP, FP, FN = result_dict['tp'], result_dict['fp'], result_dict['fn']

    precision = TP * 1.0 / (TP + FP + 1e-9)
    recall = TP * 1.0 / (TP + FN + 1e-9)
    F1 = 2 * precision*recall / (precision + recall + 1e-9)

    logger.info(
        f"Result: \n"
        f"Precision:   {precision}\n"
        f"Recall:   {recall}\n"
        f"F1:   {F1}"
    )
    return {"Precision": precision, "Recall": recall, "F1": F1}

